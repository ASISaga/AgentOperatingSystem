name: Infrastructure Deployment Agent

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (dev, staging, prod)'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      resource_group:
        description: 'Azure resource group name (auto-generated from environment if empty)'
        required: false
        type: string
      location:
        description: 'Primary Azure region (auto-selected if empty)'
        required: false
        type: string
        default: ''
      geography:
        description: 'Geographic preference for auto-region selection (used when location is empty)'
        required: false
        type: choice
        options:
          - ''
          - americas
          - europe
          - asia
        default: ''
      template:
        description: 'Bicep template file path'
        required: false
        type: string
        default: 'deployment/main-modular.bicep'
      skip_health_checks:
        description: 'Skip post-deployment health checks'
        required: false
        type: boolean
        default: false
  
  pull_request:
    types: [labeled]
    paths:
      - 'deployment/**/*.bicep'
      - 'deployment/**/*.bicepparam'
      - 'deployment/deploy.py'
      - 'deployment/orchestrator/**'
  
  issue_comment:
    types: [created]

permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

jobs:
  # Pre-flight checks and environment setup
  setup:
    name: Setup and Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment: ${{ steps.check.outputs.environment }}
      resource_group: ${{ steps.check.outputs.resource_group }}
      location: ${{ steps.check.outputs.location }}
      location_ml: ${{ steps.check.outputs.location_ml }}
      geography: ${{ steps.check.outputs.geography }}
      template: ${{ steps.check.outputs.template }}
      parameters_file: ${{ steps.check.outputs.parameters_file }}
      is_dry_run: ${{ steps.check.outputs.is_dry_run }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Check deployment trigger and intent
        id: check
        run: |
          echo "üîç Analyzing deployment intent..."
          
          # Default values
          SHOULD_DEPLOY="false"
          IS_DRY_RUN="true"
          ENVIRONMENT="dev"
          RESOURCE_GROUP="${{ github.event.inputs.resource_group }}"
          LOCATION="${{ github.event.inputs.location }}"
          GEOGRAPHY="${{ github.event.inputs.geography }}"
          TEMPLATE="${{ github.event.inputs.template || 'deployment/main-modular.bicep' }}"
          PARAMETERS_FILE=""
          
          # Determine trigger type and intent
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "üìã Manual deployment requested"
            SHOULD_DEPLOY="true"
            IS_DRY_RUN="false"
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            PARAMETERS_FILE="deployment/parameters/${ENVIRONMENT}.bicepparam"
          
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "üîÄ Pull request event detected"
            
            # Check for deployment labels
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'deploy:dev') }}" == "true" ]]; then
              echo "üè∑Ô∏è  Label 'deploy:dev' found - will deploy to dev"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="dev"
              PARAMETERS_FILE="deployment/parameters/dev.bicepparam"
            elif [[ "${{ contains(github.event.pull_request.labels.*.name, 'deploy:staging') }}" == "true" ]]; then
              echo "üè∑Ô∏è  Label 'deploy:staging' found - will deploy to staging"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="staging"
              PARAMETERS_FILE="deployment/parameters/staging.bicepparam"
            elif [[ "${{ contains(github.event.pull_request.labels.*.name, 'status:approved') }}" == "true" ]] && \
                 [[ "${{ contains(github.event.pull_request.labels.*.name, 'action:deploy') }}" == "true" ]]; then
              echo "üè∑Ô∏è  Labels 'status:approved' and 'action:deploy' found - will deploy to prod"
              SHOULD_DEPLOY="true"
              IS_DRY_RUN="false"
              ENVIRONMENT="prod"
              PARAMETERS_FILE="deployment/parameters/prod.bicepparam"
            else
              echo "üìä No deployment labels - will run plan/dry-run only"
              IS_DRY_RUN="true"
            fi
            
            # Resource group defaults to environment-based name for PR events
            if [[ -z "$RESOURCE_GROUP" ]]; then
              RESOURCE_GROUP="aos-${ENVIRONMENT}-rg"
            fi
          
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            echo "üí¨ Comment event detected"
            COMMENT_BODY="${{ github.event.comment.body }}"
            
            # Check for deployment commands in comments
            if echo "$COMMENT_BODY" | grep -qE "^/deploy (dev|staging|prod)"; then
              ENVIRONMENT=$(echo "$COMMENT_BODY" | grep -oE "^/deploy (dev|staging|prod)" | awk '{print $2}')
              echo "üöÄ Deployment command found: /deploy $ENVIRONMENT"
              SHOULD_DEPLOY="true"
              IS_DRY_RUN="false"
              RESOURCE_GROUP="aos-${ENVIRONMENT}-rg"
              PARAMETERS_FILE="deployment/parameters/${ENVIRONMENT}.bicepparam"
            elif echo "$COMMENT_BODY" | grep -qE "^/plan"; then
              echo "üìã Plan command found: /plan"
              IS_DRY_RUN="true"
              RESOURCE_GROUP="aos-${ENVIRONMENT}-rg"
            fi
          fi
          
          # Default resource group name when none supplied
          if [[ -z "$RESOURCE_GROUP" ]]; then
            RESOURCE_GROUP="aos-${ENVIRONMENT}-rg"
          fi

          # Output results (location/location_ml resolved in the next step)
          echo "should_deploy=${SHOULD_DEPLOY}" >> $GITHUB_OUTPUT
          echo "is_dry_run=${IS_DRY_RUN}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "resource_group=${RESOURCE_GROUP}" >> $GITHUB_OUTPUT
          echo "location=${LOCATION}" >> $GITHUB_OUTPUT
          echo "geography=${GEOGRAPHY}" >> $GITHUB_OUTPUT
          echo "template=${TEMPLATE}" >> $GITHUB_OUTPUT
          echo "parameters_file=${PARAMETERS_FILE}" >> $GITHUB_OUTPUT
          
          # Summary
          echo "## Deployment Intent Analysis" >> $GITHUB_STEP_SUMMARY
          echo "- **Should Deploy**: ${SHOULD_DEPLOY}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run**: ${IS_DRY_RUN}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${RESOURCE_GROUP}" >> $GITHUB_STEP_SUMMARY
          echo "- **Location (user-provided)**: ${LOCATION:-'(auto-select)'}" >> $GITHUB_STEP_SUMMARY
          echo "- **Template**: ${TEMPLATE}" >> $GITHUB_STEP_SUMMARY
          echo "- **Parameters**: ${PARAMETERS_FILE}" >> $GITHUB_STEP_SUMMARY

  # Agent Layer: Orchestrate the deployment
  deploy:
    name: Deploy Infrastructure (Agent Layer)
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true' || needs.setup.outputs.is_dry_run == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Post deployment start comment
        if: github.event_name == 'pull_request' || github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = '${{ needs.setup.outputs.is_dry_run }}' === 'true';
            const environment = '${{ needs.setup.outputs.environment }}';
            const mode = isDryRun ? 'Plan/Analysis' : 'Deployment';
            
            const body = `## üöÄ Infrastructure ${mode} Started
            
            **Environment**: \`${environment}\`
            **Resource Group**: \`${{ needs.setup.outputs.resource_group }}\`
            **Region**: auto-selecting optimal region(s) for each service‚Ä¶
            **Template**: \`${{ needs.setup.outputs.template }}\`
            
            ${isDryRun ? 'üìä Running in **plan mode** - no actual changes will be made.' : '‚öôÔ∏è  Running **live deployment** - infrastructure will be modified.'}
            
            The agent is now analyzing the deployment...
            `;
            
            if (context.eventName === 'pull_request') {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install Python dependencies
        run: |
          echo "üì¶ Installing Python dependencies..."
          cd deployment
          pip install -r orchestrator/requirements.txt
          pip install --upgrade azure-cli
      
      - name: Verify Azure CLI
        run: |
          echo "üîß Verifying Azure CLI installation..."
          az version
      
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Verify Azure authentication
        run: |
          echo "‚úÖ Verifying Azure authentication..."
          az account show
          az account list --output table
      
      - name: Auto-Select Deployment Regions
        id: region_select
        run: |
          echo "üåç Auto-selecting optimal regions for each service..."
          
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"
          USER_LOCATION="${{ needs.setup.outputs.location }}"
          GEOGRAPHY="${{ needs.setup.outputs.geography }}"

          if [[ -n "$USER_LOCATION" ]]; then
            echo "‚ÑπÔ∏è  User specified primary region: $USER_LOCATION"
            PRIMARY_REGION="$USER_LOCATION"
            # Still auto-select ML region in case primary doesn't support it
            GEO_ARG=""
            [[ -n "$GEOGRAPHY" ]] && GEO_ARG="--geography $GEOGRAPHY"
            ML_RESULT=$(python3 deployment/orchestrator/cli/regional_tool.py \
              auto-select --environment "$ENVIRONMENT" $GEO_ARG --json 2>/dev/null)
            ML_REGION=$(echo "$ML_RESULT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['ml_region'])")
            # If primary supports ML, use it; otherwise use auto-selected ML region
            VALIDATE=$(python3 deployment/orchestrator/cli/regional_tool.py \
              validate "$PRIMARY_REGION" azureml --json 2>/dev/null)
            ML_VALID=$(echo "$VALIDATE" | python3 -c "import sys,json; d=json.load(sys.stdin); print(str(d.get('is_valid', False)).lower())" 2>/dev/null || echo "false")
            [[ "$ML_VALID" == "true" ]] && ML_REGION="$PRIMARY_REGION"
          else
            echo "‚ÑπÔ∏è  No region specified ‚Äì running auto-selection..."
            GEO_ARG=""
            [[ -n "$GEOGRAPHY" ]] && GEO_ARG="--geography $GEOGRAPHY"
            RESULT=$(python3 deployment/orchestrator/cli/regional_tool.py \
              auto-select --environment "$ENVIRONMENT" $GEO_ARG --json)
            echo "$RESULT"
            PRIMARY_REGION=$(echo "$RESULT" | python3 -c "import sys,json; print(json.load(sys.stdin)['primary_region'])")
            ML_REGION=$(echo "$RESULT" | python3 -c "import sys,json; print(json.load(sys.stdin)['ml_region'])")
            MULTI_REGION=$(echo "$RESULT" | python3 -c "import sys,json; print(str(json.load(sys.stdin)['multi_region']).lower())")
            if [[ "$MULTI_REGION" == "true" ]]; then
              echo "‚ö†Ô∏è  Multi-region deployment: core ‚Üí $PRIMARY_REGION, ML/ACR ‚Üí $ML_REGION"
            else
              echo "‚úÖ Single-region deployment: $PRIMARY_REGION"
            fi
          fi

          echo "primary_region=${PRIMARY_REGION}" >> $GITHUB_OUTPUT
          echo "ml_region=${ML_REGION}" >> $GITHUB_OUTPUT

          # Write to step summary
          echo "## üåç Auto-Selected Regions" >> $GITHUB_STEP_SUMMARY
          echo "- **Primary Region**: \`${PRIMARY_REGION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Azure ML Region**: \`${ML_REGION}\`" >> $GITHUB_STEP_SUMMARY
          if [[ "$PRIMARY_REGION" != "$ML_REGION" ]]; then
            echo "- ‚ö†Ô∏è  **Multi-Region**: core services in \`${PRIMARY_REGION}\`, Azure ML in \`${ML_REGION}\`" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Create Resource Groups
        run: |
          echo "üìÇ Creating resource groups if they do not exist..."
          
          PRIMARY_REGION="${{ steps.region_select.outputs.primary_region }}"
          ML_REGION="${{ steps.region_select.outputs.ml_region }}"
          RESOURCE_GROUP="${{ needs.setup.outputs.resource_group }}"
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"

          # Primary resource group
          echo "  Creating '$RESOURCE_GROUP' in '$PRIMARY_REGION'..."
          az group create \
            --name "$RESOURCE_GROUP" \
            --location "$PRIMARY_REGION" \
            --tags Environment="$ENVIRONMENT" Application=AgentOperatingSystem ManagedBy=GitHubActions \
            --output table

          # Separate ML resource group when deploying to a different region
          if [[ "$PRIMARY_REGION" != "$ML_REGION" ]]; then
            if [[ "$RESOURCE_GROUP" == *-rg ]]; then
              ML_RESOURCE_GROUP="${RESOURCE_GROUP%-rg}-ml-rg"
            else
              ML_RESOURCE_GROUP="${RESOURCE_GROUP}-ml-rg"
            fi
            echo "  Creating ML resource group '$ML_RESOURCE_GROUP' in '$ML_REGION'..."
            az group create \
              --name "$ML_RESOURCE_GROUP" \
              --location "$ML_REGION" \
              --tags Environment="$ENVIRONMENT" Application=AgentOperatingSystem ManagedBy=GitHubActions Component=MachineLearning \
              --output table
          fi
      
      - name: Regional Capability Validation
        id: regional_validation
        run: |
          echo "üåç Validating regional capabilities..."
          
          PRIMARY_REGION="${{ steps.region_select.outputs.primary_region }}"
          ML_REGION="${{ steps.region_select.outputs.ml_region }}"
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"
          
          # Determine required services based on environment
          SERVICES="storage keyvault functions servicebus appinsights loganalytics identity"
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            SERVICES="$SERVICES functions-premium servicebus-premium azureml acr"
          elif [[ "$ENVIRONMENT" == "staging" ]]; then
            SERVICES="$SERVICES functions-premium azureml"
          fi
          
          echo "Primary Region : $PRIMARY_REGION"
          echo "ML Region      : $ML_REGION"
          echo "Environment    : $ENVIRONMENT"
          echo "Services       : $SERVICES"
          
          # Validate primary region (excluding ML services)
          CORE_SERVICES="storage keyvault functions servicebus appinsights loganalytics identity"
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            CORE_SERVICES="$CORE_SERVICES functions-premium servicebus-premium"
          elif [[ "$ENVIRONMENT" == "staging" ]]; then
            CORE_SERVICES="$CORE_SERVICES functions-premium"
          fi

          echo ""
          echo "--- Primary region validation ---"
          python3 deployment/orchestrator/cli/regional_tool.py validate "$PRIMARY_REGION" $CORE_SERVICES > validation-output.txt 2>&1
          VALIDATION_EXIT=$?
          cat validation-output.txt

          # Validate ML region when applicable
          if [[ "$ENVIRONMENT" != "dev" ]]; then
            echo ""
            echo "--- ML region validation ($ML_REGION) ---"
            python3 deployment/orchestrator/cli/regional_tool.py validate "$ML_REGION" azureml acr > ml-validation-output.txt 2>&1
            cat ml-validation-output.txt
          fi

          if [[ $VALIDATION_EXIT -ne 0 ]]; then
            echo ""
            echo "‚ÑπÔ∏è  Some services have warnings in primary region - auto-selection already handled fallback."
          else
            echo "‚úÖ Primary region $PRIMARY_REGION supports all required core services"
          fi
          
          # Save validation results
          echo "validation_exit=$VALIDATION_EXIT" >> $GITHUB_OUTPUT
          
          # Generate deployment summary
          echo ""
          echo "üìä Deployment Summary for $PRIMARY_REGION:"
          python3 deployment/orchestrator/cli/regional_tool.py summary "$PRIMARY_REGION" $CORE_SERVICES
      
      - name: Execute Python Orchestrator (Logic Layer)
        id: orchestrator
        continue-on-error: true
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          echo "üêç Executing Python orchestration layer..."
          
          PRIMARY_REGION="${{ steps.region_select.outputs.primary_region }}"
          ML_REGION="${{ steps.region_select.outputs.ml_region }}"
          
          # Build command with auto-resolved regions
          CMD="python3 deployment/deploy.py \
            --resource-group '${{ needs.setup.outputs.resource_group }}' \
            --location '${PRIMARY_REGION}' \
            --location-ml '${ML_REGION}' \
            --environment '${{ needs.setup.outputs.environment }}' \
            --template '${{ needs.setup.outputs.template }}'"
          
          # Add parameters file if exists
          if [[ -n "${{ needs.setup.outputs.parameters_file }}" ]] && [[ -f "${{ needs.setup.outputs.parameters_file }}" ]]; then
            CMD="$CMD --parameters '${{ needs.setup.outputs.parameters_file }}'"
          fi
          
          # Add flags
          CMD="$CMD --allow-warnings"
          CMD="$CMD --git-sha '${{ github.sha }}'"
          
          if [[ "${{ needs.setup.outputs.skip_health_checks }}" == "true" ]]; then
            CMD="$CMD --skip-health"
          fi
          
          # For dry-run/plan, we still run the orchestrator which does what-if analysis
          # The orchestrator will stop before actual deployment if we don't confirm
          if [[ "${{ needs.setup.outputs.is_dry_run }}" == "true" ]]; then
            echo "üìã Running in PLAN mode (dry-run)"
            CMD="$CMD --no-confirm-deletes"  # Will still do what-if, just won't prompt
          fi
          
          echo "Executing: $CMD"
          
          # Execute and capture output
          set +e
          eval "$CMD" 2>&1 | tee orchestrator-output.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          echo "exit_code=${EXIT_CODE}" >> $GITHUB_OUTPUT
          
          # Save output for later analysis
          if [[ -f "orchestrator-output.log" ]]; then
            echo "output_file=orchestrator-output.log" >> $GITHUB_OUTPUT
          fi
          
          exit ${EXIT_CODE}
      
      - name: Analyze orchestrator output (Agent Intelligence)
        id: analyze
        if: always()
        run: |
          echo "üß† Agent analyzing orchestrator output..."
          
          EXIT_CODE="${{ steps.orchestrator.outputs.exit_code }}"
          OUTPUT_FILE="${{ steps.orchestrator.outputs.output_file }}"
          
          # Initialize analysis variables
          FAILURE_TYPE="unknown"
          ERROR_MESSAGE=""
          SHOULD_RETRY="false"
          IS_TRANSIENT="false"
          
          if [[ -f "$OUTPUT_FILE" ]]; then
            # Extract key information from output
            
            # Check for success
            if grep -q "DEPLOYMENT SUCCESSFUL\|‚úÖ" "$OUTPUT_FILE"; then
              echo "‚úÖ Deployment succeeded"
              echo "status=success" >> $GITHUB_OUTPUT
              echo "failure_type=none" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Check for errors
            if grep -q "DEPLOYMENT FAILED\|‚ùå" "$OUTPUT_FILE"; then
              echo "‚ùå Deployment failed - analyzing failure type..."
              
              # Extract error message
              ERROR_MESSAGE=$(grep -A 10 "DEPLOYMENT FAILED\|‚ùå" "$OUTPUT_FILE" | head -20)
              
              # Classify failure type using patterns from failure_classifier.py
              
              # Check for logic failures (syntax, validation, etc.)
              if echo "$ERROR_MESSAGE" | grep -qiE "lint.*error|bicep.*error|syntax.*error|validation.*failed|invalid.*parameter|invalid.*bicep|missing.*required.*parameter|template.*validation.*error|circular.*dependency|resource.*type.*not.*found|api.*version.*not.*supported|property.*not.*allowed|deployment.*template.*validation.*failed|parameter.*must be|error\s*bcp[0-9]+|invalidtemplatedeployment|template deployment.*is not valid"; then
                FAILURE_TYPE="logic"
                echo "üî¥ Logic failure detected - code/template error"
                SHOULD_RETRY="false"
              
              # Check for environmental failures (throttling, timeouts, etc.)
              elif echo "$ERROR_MESSAGE" | grep -qiE "timeout|throttl(ed|ing)|rate.*limit|service.*unavailable|internal.*server.*error|network.*error|network.*timeout|connection.*refused|connection.*timeout|temporary.*failure|quota.*exceeded|capacity.*unavailable|region.*unavailable|sku.*not.*available|conflict.*another.*operation|code:\s*conflict|another operation.*in progress"; then
                FAILURE_TYPE="environmental"
                IS_TRANSIENT="true"
                SHOULD_RETRY="true"
                echo "üü° Environmental failure detected - transient Azure issue"
              else
                FAILURE_TYPE="unknown"
                SHOULD_RETRY="false"
                echo "üü† Unknown failure type"
              fi
              
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "failure_type=${FAILURE_TYPE}" >> $GITHUB_OUTPUT
              echo "should_retry=${SHOULD_RETRY}" >> $GITHUB_OUTPUT
              echo "is_transient=${IS_TRANSIENT}" >> $GITHUB_OUTPUT
              
              # Save error for reporting
              echo "$ERROR_MESSAGE" > error-message.txt
              echo "error_file=error-message.txt" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  No output file found"
            echo "status=unknown" >> $GITHUB_OUTPUT
            echo "failure_type=unknown" >> $GITHUB_OUTPUT
          fi
      
      - name: Autonomous logic error fixing
        id: fix_logic_error
        if: steps.analyze.outputs.failure_type == 'logic'
        continue-on-error: true
        run: |
          echo "ü§ñ Autonomous error fixing: Attempting to fix logic error..."
          
          ERROR_FILE="${{ steps.analyze.outputs.error_file }}"
          
          if [[ ! -f "$ERROR_FILE" ]]; then
            echo "‚ùå Error file not found: $ERROR_FILE"
            echo "fix_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Run autonomous error fixer
          python3 .github/skills/deployment-error-fixer/scripts/fix_error.py \
            --error-file "$ERROR_FILE" \
            --deployment-dir deployment/ \
            --auto-fix \
            2>&1 | tee fix-output.log
          
          FIX_EXIT_CODE=$?
          
          if [[ $FIX_EXIT_CODE -eq 0 ]]; then
            echo "‚úÖ Error fixed autonomously!"
            echo "fix_success=true" >> $GITHUB_OUTPUT
            
            # Re-run deployment after fix
            echo ""
            echo "üîÑ Retrying deployment after autonomous fix..."
            
            CMD="python3 deployment/deploy.py \
              --resource-group '${{ needs.setup.outputs.resource_group }}' \
              --location '${{ steps.region_select.outputs.primary_region }}' \
              --location-ml '${{ steps.region_select.outputs.ml_region }}' \
              --environment '${{ needs.setup.outputs.environment }}' \
              --template '${{ needs.setup.outputs.template }}'"
            
            if [[ -n "${{ needs.setup.outputs.parameters_file }}" ]] && [[ -f "${{ needs.setup.outputs.parameters_file }}" ]]; then
              CMD="$CMD --parameters '${{ needs.setup.outputs.parameters_file }}'"
            fi
            
            CMD="$CMD --allow-warnings --git-sha '${{ github.sha }}'"
            
            set +e
            eval "$CMD" 2>&1 | tee orchestrator-retry-after-fix.log
            RETRY_EXIT_CODE=${PIPESTATUS[0]}
            set -e
            
            if [[ $RETRY_EXIT_CODE -eq 0 ]]; then
              echo "‚úÖ Deployment succeeded after autonomous fix!"
              echo "retry_success=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ùå Deployment still failed after fix"
              echo "retry_success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "‚ùå Could not auto-fix error"
            echo "fix_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Self-healing retry (Environmental failures only)
        id: retry
        if: steps.analyze.outputs.should_retry == 'true' && steps.analyze.outputs.is_transient == 'true'
        continue-on-error: true
        run: |
          echo "üîÑ Self-healing: Retrying deployment due to transient failure..."
          
          # Exponential backoff
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            BACKOFF_DELAY=$((2 ** RETRY_COUNT * 30))  # 60s, 120s, 240s
            
            echo "üïê Retry attempt ${RETRY_COUNT}/${MAX_RETRIES} - waiting ${BACKOFF_DELAY} seconds..."
            sleep ${BACKOFF_DELAY}
            
            echo "üîÑ Attempting deployment (retry ${RETRY_COUNT})..."
            
            # Re-run orchestrator with the same auto-selected regions
            CMD="python3 deployment/deploy.py \
              --resource-group '${{ needs.setup.outputs.resource_group }}' \
              --location '${{ steps.region_select.outputs.primary_region }}' \
              --location-ml '${{ steps.region_select.outputs.ml_region }}' \
              --environment '${{ needs.setup.outputs.environment }}' \
              --template '${{ needs.setup.outputs.template }}'"
            
            if [[ -n "${{ needs.setup.outputs.parameters_file }}" ]] && [[ -f "${{ needs.setup.outputs.parameters_file }}" ]]; then
              CMD="$CMD --parameters '${{ needs.setup.outputs.parameters_file }}'"
            fi
            
            CMD="$CMD --allow-warnings --git-sha '${{ github.sha }}'"
            
            set +e
            eval "$CMD" 2>&1 | tee "orchestrator-retry-${RETRY_COUNT}.log"
            EXIT_CODE=${PIPESTATUS[0]}
            set -e
            
            if [[ $EXIT_CODE -eq 0 ]]; then
              echo "‚úÖ Retry ${RETRY_COUNT} succeeded!"
              echo "retry_success=true" >> $GITHUB_OUTPUT
              echo "retry_count=${RETRY_COUNT}" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ùå Retry ${RETRY_COUNT} failed"
              
              # Check if still transient
              if grep -qiE "timeout|throttl|rate.*limit|service.*unavailable|network.*error|temporary.*failure" "orchestrator-retry-${RETRY_COUNT}.log"; then
                echo "Still transient error - will retry..."
                continue
              else
                echo "Error changed to non-transient - stopping retries"
                echo "retry_success=false" >> $GITHUB_OUTPUT
                echo "retry_count=${RETRY_COUNT}" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done
          
          echo "‚ùå All ${MAX_RETRIES} retries exhausted"
          echo "retry_success=false" >> $GITHUB_OUTPUT
          echo "retry_count=${RETRY_COUNT}" >> $GITHUB_OUTPUT
          exit 1
      
      - name: Extract deployment summary
        id: summary
        if: always()
        run: |
          echo "üìä Extracting deployment summary..."
          
          # Check if audit logs exist
          if [[ -d "deployment/audit" ]]; then
            LATEST_AUDIT=$(ls -t deployment/audit/*.json 2>/dev/null | head -1)
            if [[ -f "$LATEST_AUDIT" ]]; then
              echo "üìã Found audit log: $LATEST_AUDIT"
              
              # Extract key metrics
              DEPLOYED_RESOURCES=$(jq -r '.deployed_resources | length' "$LATEST_AUDIT" 2>/dev/null || echo "0")
              DURATION=$(jq -r '.duration_seconds' "$LATEST_AUDIT" 2>/dev/null || echo "N/A")
              
              echo "deployed_resources=${DEPLOYED_RESOURCES}" >> $GITHUB_OUTPUT
              echo "duration=${DURATION}" >> $GITHUB_OUTPUT
              echo "audit_file=${LATEST_AUDIT}" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Post deployment result comment
        if: always() && (github.event_name == 'pull_request' || github.event_name == 'issue_comment')
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.analyze.outputs.status }}';
            const failureType = '${{ steps.analyze.outputs.failure_type }}';
            const retrySuccess = '${{ steps.retry.outputs.retry_success }}';
            const retryCount = '${{ steps.retry.outputs.retry_count }}';
            const fixSuccess = '${{ steps.fix_logic_error.outputs.fix_success }}';
            const fixRetrySuccess = '${{ steps.fix_logic_error.outputs.retry_success }}';
            const environment = '${{ needs.setup.outputs.environment }}';
            const isDryRun = '${{ needs.setup.outputs.is_dry_run }}' === 'true';
            
            let emoji = '‚ùì';
            let statusText = 'Unknown';
            let details = '';
            
            if (status === 'success' || retrySuccess === 'true' || fixRetrySuccess === 'true') {
              emoji = '‚úÖ';
              statusText = 'Successful';
              
              if (retrySuccess === 'true') {
                details = `\n\n**Self-Healing**: The deployment initially failed with a transient error, but succeeded after ${retryCount} retry attempt(s). üîÑ‚ú®`;
              }
              
              if (fixRetrySuccess === 'true') {
                details = `\n\n**Autonomous Fix**: The deployment initially failed with a logic error, but the agent autonomously fixed the issue and deployment succeeded! ü§ñ‚ú®`;
              }
              
              const deployedResources = '${{ steps.summary.outputs.deployed_resources }}';
              const duration = '${{ steps.summary.outputs.duration }}';
              
              if (deployedResources && deployedResources !== '0') {
                details += `\n\n**Deployed Resources**: ${deployedResources}`;
              }
              if (duration && duration !== 'N/A') {
                details += `\n**Duration**: ${duration} seconds`;
              }
            } else if (status === 'failed') {
              emoji = '‚ùå';
              statusText = 'Failed';
              
              if (failureType === 'logic') {
                if (fixSuccess === 'false') {
                  details = `\n\n**Failure Type**: Logic Error (Code/Template)\n**Autonomous Fix**: Attempted but failed\n**Action Required**: The agent could not automatically fix this error. Please review the logs and fix manually.\n\n‚ö†Ô∏è This is a code error that requires manual intervention.`;
                } else {
                  details = `\n\n**Failure Type**: Logic Error (Code/Template)\n**Action Required**: Please fix the Bicep template or parameters and try again.\n\n‚ö†Ô∏è **No retry attempted** - this is a code error that requires manual intervention.`;
                }
              } else if (failureType === 'environmental') {
                if (retrySuccess === 'false') {
                  details = `\n\n**Failure Type**: Environmental (Transient Azure Issue)\n**Retries Attempted**: ${retryCount || 'N/A'}\n\n‚ö†Ô∏è The issue persisted after retry attempts. This may require:\n- Checking Azure service health\n- Trying again later\n- Adjusting resource configurations`;
                } else {
                  details = `\n\n**Failure Type**: Environmental (Transient Azure Issue)\n**Retries**: In progress...`;
                }
              } else {
                details = `\n\n**Failure Type**: Unknown\n**Action Required**: Please check the workflow logs for details.`;
              }
            }
            
            const mode = isDryRun ? 'Plan/Analysis' : 'Deployment';
            
            const body = `## ${emoji} Infrastructure ${mode} ${statusText}
            
            **Environment**: \`${environment}\`
            **Resource Group**: \`${{ needs.setup.outputs.resource_group }}\`
            **Primary Region**: \`${{ steps.region_select.outputs.primary_region }}\`
            **Azure ML Region**: \`${{ steps.region_select.outputs.ml_region }}\`
            **Status**: ${statusText}
            ${details}
            
            ${isDryRun ? 'üìä This was a **plan/dry-run** - no actual infrastructure changes were made.' : ''}
            
            [View workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            if (context.eventName === 'pull_request') {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }
      
      - name: Upload audit logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-audit-${{ github.run_id }}
          path: |
            deployment/audit/*.json
            orchestrator-*.log
            error-message.txt
          retention-days: 90
          if-no-files-found: ignore
      
      - name: Final status check
        if: always()
        run: |
          STATUS="${{ steps.analyze.outputs.status }}"
          RETRY_SUCCESS="${{ steps.retry.outputs.retry_success }}"
          FIX_RETRY_SUCCESS="${{ steps.fix_logic_error.outputs.retry_success }}"
          
          if [[ "$STATUS" == "success" ]] || [[ "$RETRY_SUCCESS" == "true" ]] || [[ "$FIX_RETRY_SUCCESS" == "true" ]]; then
            echo "‚úÖ Deployment workflow completed successfully"
            exit 0
          elif [[ "${{ needs.setup.outputs.is_dry_run }}" == "true" ]]; then
            echo "üìä Plan/dry-run completed"
            exit 0
          else
            echo "‚ùå Deployment workflow failed"
            exit 1
          fi
